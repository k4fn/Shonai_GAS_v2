/**
 * @fileoverview
 * 折衝表スプレッドシートから情報を読み取り、学内集会願スプレッドシートを生成するスクリプト。
 * 各部屋の利用状況を月ごとにまとめ、指定された形式で新しいシートに書き出す。
 * また、サークルメンバーへの周知用サマリーシートも作成する。
 */

//-------------------------- 設定 (グローバル変数) --------------------------
// 折衝表のスプレッドシートのURL
const NEGOTIATION_SHEET_URL = 'https://docs.google.com/spreadsheets/d/xxxxxxxxxxxxxxx';
// サークル名 (折衝表で検索する値)
const CIRCLE_NAME = 'xxx部';
// 作成する学内集会願のファイル名のプレフィックス (月が後で追加されます)
const NEW_SPREADSHEET_BASE_NAME = 'xxx部_学内集会願コピペ_';
// 学内集会願のテンプレートシートのURL
const TEMPLATE_SPREADSHEET_URL = 'https://docs.google.com/spreadsheets/d/xxxxxxxxxxxxxxx';
// 作成した学内集会願を保存するGoogle DriveフォルダーのID (空文字の場合はマイドライブ直下)
const OUTPUT_FOLDER_ID = 'xxxxxxxxxxxxxxx';
// 処理対象の部屋名のリスト
const ROOMS = ['4203', '4302', '5405A', '5405B', '5505', '防音室B', '防音室C'];
// 授業時間帯の開始時刻リスト (1限目から順に)
const START_TIMES = ['9:20', '11:10', '12:50', '13:40', '15:30', '17:20', '19:10', '21:00'];
// 授業時間帯の終了時刻リスト (1限目から順に)
const END_TIMES = ['11:00', '12:50', '13:40', '15:20', '17:10', '19:00', '20:50', '22:00'];
// 学内集会願に記入する利用人数
const NUMBER_OF_USERS = '5';
// 学内集会願の1シートあたりの最大行数 (これを超えると新しいシートが作成される)
const ROWS_PER_MEETING_SHEET = 14;

// --- 折衝表シートの構造に関する設定 ---
const NEGOTIATION_SHEET_DATE_COLUMN = 1; // 日付が記載されている列 (A列=1)
const NEGOTIATION_SHEET_START_PERIOD_COLUMN = 3; // 1限目のデータが始まる列 (C列=3)
const NEGOTIATION_SHEET_NUMBER_OF_PERIODS = 8; // 時間割のコマ数 (例: 1限目～8限目/放課後)

// --- 出力する学内集会願シートの構造に関する設定 ---
const OUTPUT_SHEET_TOTAL_COLUMNS = 27; // 書き込むデータの総列数 (A列からAA列までなら27)
// AC列までデータがあるため、バッチ書き込み用に拡張
const OUTPUT_SHEET_WRITE_COLUMNS = 29; 

const OUTPUT_SHEET_ROOM_NAME_COLUMN = 1;      // A列: 部屋名
const OUTPUT_SHEET_DATE_COLUMN = 6;          // F列: 日付 (月/日)
const OUTPUT_SHEET_DAY_OF_WEEK_COLUMN = 7;   // G列: 曜日 ((曜))
const OUTPUT_SHEET_FIRST_PERIOD_MARK_COLUMN_INDEX = 7; // H列(1限目マーク)のインデックス (0から数えて7番目)
const OUTPUT_SHEET_TIME_RANGE_COLUMN = 24;    // X列: 利用時間 (HH:MM\n～\nHH:MM)
const OUTPUT_SHEET_USERS_COLUMN = 27;        // AA列: 利用人数
const OUTPUT_SHEET_ADDITIONAL_TIMES_COLUMN = 29; // AC列: 同日の追加利用時間

// --- 周知用シートの設定 ---
const NOTIFICATION_SHEET_NAME = "周知用";
//------------------------------------------------------------------------------------

/**
 * メイン関数: 折衝表からデータを処理し、学内集会願を作成
 */
function createMeetingRequestSpreadsheets() {
  const negotiationSs = SpreadsheetApp.openByUrl(NEGOTIATION_SHEET_URL);
  const { newSs, templateSheet } = initializeOutputSpreadsheet();
  if (!newSs || !templateSheet) return; // 初期化失敗時は終了

  let scheduleForNotification = Array(32).fill(null); // [0]に月、[1]～[31]に日のデータ
  
  let processingState = {
    isFirstDataProcessed: false, // スプレッドシート名を月で更新したかどうかのフラグ
    initialSheet1: newSs.getSheetByName('シート1') // 初期に存在する「シート1」
  };

  // 各部屋について処理
  for (const roomName of ROOMS) {
    processRoomData(roomName, negotiationSs, newSs, templateSheet, scheduleForNotification, processingState);
  }

  createNotificationSheetAndFinalize(newSs, scheduleForNotification, processingState);
  // Logger.log("処理が完了しました。");
}

/**
 * 出力用スプレッドシートの初期化（作成、フォルダ移動、テンプレート読み込み）
 */
function initializeOutputSpreadsheet() {
  const newSs = SpreadsheetApp.create(NEW_SPREADSHEET_BASE_NAME + '_TEMP_NAME_');
  Logger.log(`新しいスプレッドシートを作成しました↓`);
  Logger.log(newSs.getUrl());

  if (OUTPUT_FOLDER_ID) {
    try {
      DriveApp.getFileById(newSs.getId()).moveTo(DriveApp.getFolderById(OUTPUT_FOLDER_ID));
      // Logger.log(`スプレッドシートをフォルダID "${OUTPUT_FOLDER_ID}" に移動しました。`);
    } catch (e) {
      Logger.log(`フォルダへの移動に失敗しました: ${e.toString()}. マイドライブに保存されます。`);
    }
  }

  const templateSheet = SpreadsheetApp.openByUrl(TEMPLATE_SPREADSHEET_URL).getSheetByName('テンプレ');
  if (!templateSheet) {
    SpreadsheetApp.getUi().alert('エラー', 'テンプレートシート「テンプレ」が見つかりません。URLとシート名を確認してください。', SpreadsheetApp.getUi().ButtonSet.OK);
    return { newSs: newSs, templateSheet: null };
  }
  return { newSs, templateSheet };
}

/**
 * 指定された部屋のデータを処理し、学内集会願シートに書き込み、周知用データを収集
 */
function processRoomData(roomName, negotiationSs, newSs, templateSheet, scheduleForNotification, processingState) {
  const negotiationRoomSheet = negotiationSs.getSheetByName(roomName);
  if (!negotiationRoomSheet) {
    Logger.log(`部屋 "${roomName}" のシートが折衝表に見つかりません。スキップします。`);
    return;
  }

  // --- 高速化: データを一括取得 ---
  // 2行目から32行目（31日分）、日付列から時間割の最後の列まで取得
  const totalDays = 31;
  const dataRange = negotiationRoomSheet.getRange(2, 1, totalDays, NEGOTIATION_SHEET_START_PERIOD_COLUMN + NEGOTIATION_SHEET_NUMBER_OF_PERIODS - 1);
  const allValues = dataRange.getValues(); // 2次元配列で値を取得
  
  // --- 高速化: 結合セル情報の一括取得とマッピング ---
  // 時間割部分の結合情報を取得
  const timetableRange = negotiationRoomSheet.getRange(2, NEGOTIATION_SHEET_START_PERIOD_COLUMN, totalDays, NEGOTIATION_SHEET_NUMBER_OF_PERIODS);
  const mergedRanges = timetableRange.getMergedRanges();
  
  // 利用状況マップを作成 (0:未使用, 1:使用)
  // allValuesのインデックスに対応させるため、同じサイズの配列を用意
  // ただし、時間割部分は allValues の (col index) - (NEGOTIATION_SHEET_START_PERIOD_COLUMN - 1)
  let usageMap = Array(totalDays).fill(null).map(() => Array(NEGOTIATION_SHEET_NUMBER_OF_PERIODS).fill(0));

  // 1. 通常の値から埋める
  for (let i = 0; i < totalDays; i++) {
    for (let j = 0; j < NEGOTIATION_SHEET_NUMBER_OF_PERIODS; j++) {
      // allValuesの列インデックス: 日付(0), ..., 時間割開始(2), ...
      const val = allValues[i][NEGOTIATION_SHEET_START_PERIOD_COLUMN - 1 + j];
      if (val === CIRCLE_NAME) {
        usageMap[i][j] = 1;
      }
    }
  }

  // 2. 結合セル情報から埋める
  // mergedRangesはシート全体の座標を持つので、相対座標に変換してマッピング
  for (const range of mergedRanges) {
    if (range.getDisplayValue() === CIRCLE_NAME) {
      const startRow = range.getRow() - 2; // 配列インデックスに変換 (2行目開始なので -2)
      const endRow = startRow + range.getNumRows() - 1;
      const startCol = range.getColumn() - NEGOTIATION_SHEET_START_PERIOD_COLUMN;
      const endCol = startCol + range.getNumColumns() - 1;

      for (let r = startRow; r <= endRow; r++) {
        if (r >= 0 && r < totalDays) {
          for (let c = startCol; c <= endCol; c++) {
            if (c >= 0 && c < NEGOTIATION_SHEET_NUMBER_OF_PERIODS) {
              usageMap[r][c] = 1;
            }
          }
        }
      }
    }
  }

  // --- データ処理とページデータの作成 ---
  let pagesData = []; // ページごとの書き込みデータを格納 [[row1data, row2data...], [row1data...]]
  let currentPageRows = [];

  for (let dayIndex = 0; dayIndex < totalDays; dayIndex++) {
    const dateValue = allValues[dayIndex][0]; // 日付列
    if (!dateValue || !(dateValue instanceof Date)) continue;

    const date = new Date(dateValue);
    const month = date.getMonth() + 1;
    const day = date.getDate();
    const dayOfWeek = ["日", "月", "火", "水", "木", "金", "土"][date.getDay()];

    // ファイル名更新（初回のみ）
    if (!processingState.isFirstDataProcessed) {
      newSs.rename(NEW_SPREADSHEET_BASE_NAME + month + "月");
      scheduleForNotification[0] = month;
      processingState.isFirstDataProcessed = true;
    }

    // その日の利用枠を抽出
    const dailyActivitySlots = extractSlotsFromMap(usageMap[dayIndex]);

    if (dailyActivitySlots.length > 0) {
      // 行データの作成
      const rowData = createRowData(roomName, { month, day, dayOfWeek }, dailyActivitySlots);
      currentPageRows.push(rowData);
      
      // 通知用データの更新
      updateNotificationSchedule(scheduleForNotification, day, roomName, dailyActivitySlots, dayOfWeek);

      // ページがいっぱいになったら次へ
      if (currentPageRows.length === ROWS_PER_MEETING_SHEET) {
        pagesData.push(currentPageRows);
        currentPageRows = [];
      }
    }
  }
  // 半端なページがあれば追加
  if (currentPageRows.length > 0) {
    pagesData.push(currentPageRows);
  }

  // --- シート作成と一括書き込み ---
  if (pagesData.length === 0) {
    // Logger.log(`部屋 "${roomName}" の活動データがありません。`);
    return;
  }

  // 初期シート削除フラグ処理
  if (processingState.initialSheet1) {
     // 最初のシート作成前に削除はできないので、作成後に削除するようメイン関数で制御するか、
     // ここで最初のシートを作成した直後に削除する。
     // 今回は後でまとめて削除ロジックがあるのでここでは何もしない、あるいは
     // 書き込みループ内で処理する。
  }

  pagesData.forEach((pageRows, index) => {
    const sheetPageNumber = index + 1;
    const currentMeetingRequestSheet = templateSheet.copyTo(newSs);
    currentMeetingRequestSheet.setName(`${roomName}_${sheetPageNumber}`);

    if (processingState.initialSheet1) {
        try { newSs.deleteSheet(processingState.initialSheet1); } catch(e){}
        processingState.initialSheet1 = null;
    }

    // バッチ書き込み
    // pageRows は [ [col1, col2... col29], ... ] の形
    // 書き込み開始位置は 1行1列目から、行数はデータの数、列数は設定値
    if (pageRows.length > 0) {
      currentMeetingRequestSheet.getRange(1, 1, pageRows.length, OUTPUT_SHEET_WRITE_COLUMNS).setValues(pageRows);
    }
  });
}

/**
 * 使用状況マップの1行分から活動スロットを抽出
 */
function extractSlotsFromMap(dailyUsage) {
  let activitySlots = [];
  for (let k = 0; k < dailyUsage.length; k++) {
    if (dailyUsage[k] === 1) {
      const startPeriodIndex = k;
      while (k < dailyUsage.length && dailyUsage[k] === 1) k++;
      const endPeriodIndex = k - 1;
      activitySlots.push({
        startPeriod: startPeriodIndex,
        endPeriod: endPeriodIndex,
        startTime: START_TIMES[startPeriodIndex],
        endTime: END_TIMES[endPeriodIndex]
      });
    }
  }
  return activitySlots;
}

/**
 * 1行分の書き込みデータを作成（配列生成）
 */
function createRowData(roomName, dateInfo, dailyActivitySlots) {
  let outputRowData = Array(OUTPUT_SHEET_WRITE_COLUMNS).fill('');
  
  outputRowData[OUTPUT_SHEET_ROOM_NAME_COLUMN - 1] = roomName;
  outputRowData[OUTPUT_SHEET_DATE_COLUMN - 1] = `${dateInfo.month}/${dateInfo.day}`;
  outputRowData[OUTPUT_SHEET_DAY_OF_WEEK_COLUMN - 1] = `(${dateInfo.dayOfWeek})`;

  dailyActivitySlots.forEach(slot => {
    for (let period = slot.startPeriod; period <= slot.endPeriod; period++) {
      outputRowData[OUTPUT_SHEET_FIRST_PERIOD_MARK_COLUMN_INDEX + period * 2] = '〇';
    }
  });

  const firstSlot = dailyActivitySlots[0];
  outputRowData[OUTPUT_SHEET_TIME_RANGE_COLUMN - 1] = `${firstSlot.startTime}\n～\n${firstSlot.endTime}`;
  outputRowData[OUTPUT_SHEET_USERS_COLUMN - 1] = NUMBER_OF_USERS;

  // 追加時間（AC列）
  if (dailyActivitySlots.length > 1) {
    let additionalTimes = dailyActivitySlots.slice(1).map(slot => `${slot.startTime}～${slot.endTime}`);
    outputRowData[OUTPUT_SHEET_ADDITIONAL_TIMES_COLUMN - 1] = additionalTimes.join(' ');
  }
  
  return outputRowData;
}

/**
 * 周知用データ配列を更新
 */
function updateNotificationSchedule(scheduleForNotification, day, roomName, dailyActivitySlots, dayOfWeek) {
  if (!scheduleForNotification[day]) {
    scheduleForNotification[day] = [];
  }
  dailyActivitySlots.forEach(slot => {
    scheduleForNotification[day].push([roomName, slot.startTime, slot.endTime, `(${dayOfWeek})`]);
  });
}

/**
 * 周知用シートを作成
 */
function createNotificationSheetAndFinalize(newSs, scheduleForNotification, processingState) {
  if (processingState.isFirstDataProcessed) {
    const notificationString = buildNotificationString(scheduleForNotification);
    if (notificationString) {
      let notificationSheet = newSs.getSheetByName(NOTIFICATION_SHEET_NAME);
      if (notificationSheet) newSs.deleteSheet(notificationSheet);
      
      notificationSheet = newSs.insertSheet(NOTIFICATION_SHEET_NAME, newSs.getNumSheets());
      notificationSheet.getRange('A1').setValue(notificationString).setWrap(true);
      // Logger.log(`シート "${NOTIFICATION_SHEET_NAME}" を作成し、周知用情報を書き込みました。`);
    }
  }
  // initialSheet1の削除漏れがあればここで削除
  if (processingState.initialSheet1) {
      try {
        const s = newSs.getSheetByName(processingState.initialSheet1.getName());
        if(s && newSs.getSheets().length > 1) newSs.deleteSheet(s);
      } catch(e){}
  }
}

/**
 * 周知用メッセージ文字列を生成
 */
function buildNotificationString(scheduleData) {
  let builtString = "";
  const scheduleMonth = scheduleData[0]; 

  if (!scheduleMonth) return ""; 

  for (let day = 1; day <= 31; day++) {
    if (scheduleData[day] && scheduleData[day].length > 0) {
      scheduleData[day].sort((a, b) => {
        if (a[0] < b[0]) return -1; if (a[0] > b[0]) return 1;
        if (a[1] < b[1]) return -1; if (a[1] > b[1]) return 1;
        return 0;
      });
      for (let i = 0; i < scheduleData[day].length; i++) {
        const entry = scheduleData[day][i];
        const prevEntry = i > 0 ? scheduleData[day][i - 1] : null;
        if (i === 0) { 
          builtString += `\n${scheduleMonth}/${day}${entry[3]} ${entry[0]} ${entry[1]}～${entry[2]}`;
        } else if (prevEntry && entry[0] === prevEntry[0]) { 
          builtString += ` ${entry[1]}～${entry[2]}`;
        } else { 
          let padding = (day <= 9) ? "         " : "           ";
          builtString += `\n${padding}${entry[0]} ${entry[1]}～${entry[2]}`;
        }
      }
      builtString += '\n';
    }
  }
  return builtString.startsWith('\n') ? builtString.substring(1) : builtString;
}
